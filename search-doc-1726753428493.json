{"searchDocs":[{"title":"About Me","type":0,"sectionRef":"#","url":"/blog/about/about_en","content":"","keywords":"","version":null},{"title":"Hello!​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#hello","content":" Welcome to my personal homepage, and I'm glad to meet such an interesting soul as you.  ","version":null,"tagName":"h2"},{"title":"Experience​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#experience","content":" 2017 - 2020, No.1 High School of Bozhou, Bozhou Anhui2020 - 2024, College of Computer Science and Technology, Jilin University, Changchun Jilin2024 - , School of Computer Science and Engineering, Sun Yat-sen University, Guangzhou Guangdong  ","version":null,"tagName":"h2"},{"title":"Projects​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#projects","content":" Emulator based on RISC-VIntelligent picking robot using YOLOv5Some repositories HeartbeatCoursea  ","version":null,"tagName":"h2"},{"title":"Awards​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#awards","content":" (Updated on 29, August, 2023)  2020 - 2021, Second Class Scholarship, Jilin University2021 - 2022, Third Class Scholarship, Jilin University2021 - 2022, College Excellent Student, Jilin University2023, National IoT Design Competition, First Prize of Northeast Region, Second Prize of National Finals  ","version":null,"tagName":"h2"},{"title":"Competence​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#competence","content":" Good level of English, passed CET-4 and CET-6 with excellent grades, and can read foreign literature fluently.Familiar with C, C++, Java, Python, Kotlin, Swift, Go and other programming languages, with good programming ability.Familiar with HTML, CSS, JavaScript, Node.js, Vue, Bootstrap and other technologies, able to independently build web pages.Able to independently develop iOS/iPadOS/macOS and Android applications.Extensive study of software and hardware, familiar with embedded development.  ","version":null,"tagName":"h2"},{"title":"Hobbies​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#hobbies","content":" Learning languages. When I'm free, learning different languages is a wonderful way to consume time, Français, Русский, Español... those are my favorites.Painting. Just for fun :P.Reading. Kafka and Woolf are among my favorite authors. Although sometimes I don't fully understand their brilliant work, it makes me even more engrossed.Design all kinds of interesting things, insist on creating extraordinary things with ordinary materials, and express emotions with colors.Photography. Recording every moment of normal life with camera.  ","version":null,"tagName":"h2"},{"title":"My Works :)​","type":1,"pageTitle":"About Me","url":"/blog/about/about_en#my-works-","content":" Here is the first work I painted several years ago.    And this is a flower of cactus in my home.   ","version":null,"tagName":"h3"},{"title":"关于我自己","type":0,"sectionRef":"#","url":"/blog/about/about_cn","content":"","keywords":"","version":null},{"title":"你好！​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#你好","content":" 欢迎访问我的个人主页，我也非常荣幸能够同你这样有趣的灵魂在此相遇。  ","version":null,"tagName":"h2"},{"title":"学习经历​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#学习经历","content":" 2017 - 2020，高中，安徽省亳州市第一中学2020 - 2024，本科，吉林大学计算机科学与技术学院2024 - ，研究生在读，中山大学计算机学院  ","version":null,"tagName":"h2"},{"title":"参与项目​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#参与项目","content":" RISC-V 指令集软件仿真基于 YOLOv5 的智能捡拾机器人我自己的 Repositories HeartbeatCoursea  ","version":null,"tagName":"h2"},{"title":"所获荣誉​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#所获荣誉","content":" （截止至 2023 年 8 月）  2020 - 2021，吉林大学三等奖学金2021 - 2022，吉林大学二等奖学金2021 - 2022，吉林大学计算机科学与技术学院院优秀学生2023，全国大学生物联网设计竞赛，东北赛区一等奖，全国总决赛二等奖  ","version":null,"tagName":"h2"},{"title":"个人能力​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#个人能力","content":" 英语水平良好，四六级均以优秀成绩通过，正在备考 TOEFL，能够流畅地阅读外文文献。熟悉 C，C++，Java，Python，Kotlin，Swift，Go 等编程语言，有良好的编程能力。熟悉 HTML，CSS，JavaScript，Node.js，Vue，Bootstrap 等技术，能够独立搭建网页。有一定的开发经验，能够独立开发 iOS/iPadOS/macOS 和 Android 应用程序。广泛接触软硬件，基础较为扎实，熟悉嵌入式开发。  ","version":null,"tagName":"h2"},{"title":"兴趣爱好​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#兴趣爱好","content":" 语言学习。空余时间会学习各种有趣的语言，例如 Français，Русский，Español 等语言。绘画（约等于～乱画）。没有系统地学过相关知识，就是想画啥画啥。阅读文学。Kafka 和 Woolf 是我最喜欢的作家之一，虽然有时候看不太懂，但是更让我痴迷不已。设计各种有意思的东西，执着于用平凡的材料创造出不平凡的事物，用颜色表达情感。摄影。用相机记录下每一个值得回忆的瞬间。  ","version":null,"tagName":"h2"},{"title":"我的小作品 :)​","type":1,"pageTitle":"关于我自己","url":"/blog/about/about_cn#我的小作品-","content":" 这是几年前我画的第一幅画。    这是我家仙人掌开的花。   ","version":null,"tagName":"h3"},{"title":"關於我自己","type":0,"sectionRef":"#","url":"/blog/about/about_tcn","content":"","keywords":"","version":null},{"title":"你好！​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#你好","content":" 歡迎訪問我嘅個人主頁，我都非常榮幸能夠同你咁有趣嘅靈魂在此相遇。  ","version":null,"tagName":"h2"},{"title":"學習經歷​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#學習經歷","content":" 2017 - 2020，高中，安徽省亳州市第一中學2020 - 2024，本科，吉林大學計算機科學與技術學院2024 - ，研究生在讀，中山大學計算機學院  ","version":null,"tagName":"h2"},{"title":"參與項目​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#參與項目","content":" RISC-V 指令集軟件仿真基於 YOLOv5 嘅智能撿拾機械人我自己嘅 Repositories HeartbeatCoursea  ","version":null,"tagName":"h2"},{"title":"所獲榮譽​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#所獲榮譽","content":" （截止至 2023 年 8 月）  2020 - 2021，吉林大學三等獎學金2021 - 2022，吉林大學二等獎學金2021 - 2022，吉林大學計算機科學與技術學院院優秀學生2023，全國大學生物聯網設計競賽，東北賽區一等獎，全國總決賽二等獎  ","version":null,"tagName":"h2"},{"title":"個人能力​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#個人能力","content":" 英語水平良好，四六級均以優秀成績通過，正在備考 TOEFL，能夠流暢地閱讀外文文獻。熟悉 C，C++，Java，Python，Kotlin，Swift，Go 等編程語言，有良好的編程能力。熟悉 HTML，CSS，JavaScript，Node.js，Vue，Bootstrap 等技術，能夠獨立搭建網頁。有一定的開發經驗，能夠獨立開發 iOS/iPadOS/macOS 和 Android 應用程序。廣泛接觸軟硬件，基礎較為紮實，熟悉嵌入式開發。  ","version":null,"tagName":"h2"},{"title":"興趣愛好​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#興趣愛好","content":" 語言學習。空餘時間會學習各種有趣嘅語言，例如 Français，Русский，Español 等語言。繪畫（約等於~亂畫）。冇系統咁學過相關知識，就係想畫啥畫啥。閱讀文學。Kafka 同 Woolf 係我最鍾意嘅作家之一，雖然有時候睇唔係幾明，但係更令我癡迷不已。設計各種有意思嘅嘢，執著于用平凡嘅材料創造出不平凡嘅嘢，用顏色表達情感。攝影。用相機記錄的每一個值得回憶嘅瞬間。  ","version":null,"tagName":"h2"},{"title":"個人作品 :)​","type":1,"pageTitle":"關於我自己","url":"/blog/about/about_tcn#個人作品-","content":" 係幾年前我畫嘅第一幅畫。  係我屋企仙人掌開嘅花。   ","version":null,"tagName":"h3"},{"title":"Présentation de soi.","type":0,"sectionRef":"#","url":"/blog/about/about_fr","content":"","keywords":"","version":null},{"title":"Bonjour!​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#bonjour","content":" Bienvenue sur ma page d'accueil personnelle, et je suis heureux de rencontrer une âme aussi intéressante que vous.  ","version":null,"tagName":"h2"},{"title":"Expérience​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#expérience","content":" 2017 - 2020, Premier Lycée de Bozhou, Bozhou Anhui2020 - 2024, Collège d'informatique et de technologie, Université de Jilin, Changchun Jilin2024 - , École d'informatique et d'ingénierie, Sun Yat-sen University, Guangzhou Guangdong  ","version":null,"tagName":"h2"},{"title":"Projets​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#projets","content":" Émulateur basé sur RISC-VRobot de prélèvement intelligent utilisant YOLOv5Certains Github Repositories HeartbeatCoursea  ","version":null,"tagName":"h2"},{"title":"Récompenses et Honneurs​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#récompenses-et-honneurs","content":" (Mise à jour le 29, Août, 2023)  2020 - 2021, Bourse de deuxième classe, Université de Jilin2021 - 2022, Bourse de troisième classe, Université de Jilin2021 - 2022, Excellent étudiant universitaire, Université de Jilin2023, Concours national de conception IoT, Premier Prix de la Région Nord-Est, Deuxième Prix de la Finale Nationale  ","version":null,"tagName":"h2"},{"title":"Compétence​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#compétence","content":" Bon niveau d'anglais, avoir réussi les CET-4 et CET-6 avec d'excellentes notes et savoir lire couramment la littérature étrangère.Familier avec C, C++, Java, Python, Kotlin, Swift, Go et d'autres langages de programmation, avec une bonne capacité de programmation.Familier avec HTML, CSS, JavaScript, Node.js, Vue, Bootstrap et d'autres technologies, capable de créer de manière indépendante des pages Web.Capable de développer de manière indépendante des applications iOS/iPadOS/macOS et Android.Etude approfondie des logiciels et du matériel, familiarisé avec le développement embarqué.  ","version":null,"tagName":"h2"},{"title":"Loisirs​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#loisirs","content":" Apprendre des langues. Quand je suis libre, apprendre différentes langues est une merveilleuse façon de gagner du temps, Français, Русский, Español... ce sont mes préférées.Peinture. Juste pour le fun :P.En lisant. Kafka et Woolf sont parmi mes auteurs préférés. Bien que parfois je ne comprenne pas entièrement leur travail brillant, cela me rend encore plus captivé.Concevez toutes sortes de choses intéressantes, insistez pour créer des choses extraordinaires avec des matériaux ordinaires et exprimez des émotions avec des couleurs.La photographie. Enregistrement de chaque instant de la vie normale avec caméra.  ","version":null,"tagName":"h2"},{"title":"Ma Création :)​","type":1,"pageTitle":"Présentation de soi.","url":"/blog/about/about_fr#ma-création-","content":" Voici la première œuvre que j'ai peinte il y a plusieurs années.    Et c'est une fleur de cactus chez moi.   ","version":null,"tagName":"h3"},{"title":"Summary of Chapter 1","type":0,"sectionRef":"#","url":"/docs/Automata Theory/Summary of Chapter 1","content":"Summary of Chapter 1 Finite Automata: Finite automata involve states and transitions among states in response to inputs. They are useful for building several different kinds of software, including the lexical analysis component of a compiler and systems for verifying the correctness of circuits or protocols, for example.Regular Expressions: These are a structural notation for describing the same patterns that can be represented by finite automata. They are used in many common types of software, including tools to search for patterns in text or in file names, for instance.Context-Free Grammars: These are an important notation for describing the structure of programming languages and related sets of strings; they are used to build the parser component of a compiler.Turing Machines: These are automata that model the power of real computers. They allow us to study decidability, the question of what can or cannot be done by a computer. They also let us distinguish tractable problems - those that can be solved in polynomial time - from the intractable problems - those that cannot.Deductive Proofs: This basic method of proof proceeds by listing statements that are either given to be true, or that follow logically from some of the previous statements.Proving If-Then Statements: Many theorems are of the form &quot;if (something) then (something else).&quot; The statement or statements following the &quot;if&quot; are the hypothesis, and what follows &quot;then&quot; is the conclusion. Deductive proofs of if-then statements begin with the hypothesis, and continue with statements that follow logically from the hypothesis and previous statements, until the conclusion is proved as one of the statements.Proving If-And-Only-If Statements: There are other theorems of the form &quot;(something) if and only if (something else)&quot;. They are proved by showing if-then statements in both directions. A similar kind of theorem claims the equality of the sets described in two different ways; these are proved by showing that each of the two sets is contained in the other.Proving the Contrapositive: Sometimes, it is easier to prove a statement of the form &quot;if HHH then CCC&quot; by proving the equivalent statement: &quot;if not CCC then not HHH&quot;. The latter is called the contrapositive of the former.Proof by Contradiction: Other times, it is more convenient to prove the statement &quot;if HHH then CCC&quot; by proving &quot;if HHH and not CCC then (something known to be false)&quot;. A proof of this type is called proof by contradiction.Counterexamples: Sometimes we are asked to show that a certain statement is not true. If the statement has one or more parameters, then we can show it is false as a generality by providing just one counterexample, that is, one assignment of values to the parameters that makes the statement false.Inductive Proofs: A statement that has an integer parameter nnn can often be proved by induction on nnn. We prove the statement is true for the basis,a finite number of cases for particular values of nnn, and then prove the inductive step: that if the statement is true for values up to nnn, then it is true for n+1n+1n+1.Structural Inductions: In some situations, including many in this book, the theorem to be proved inductively is about some recursively defined construct, such as trees. We may prove a theorem about the constructed objects by induction on the number of steps used in its construction. This type of induction is referred to as structural.Alphabets: An alphabet is any finite set of symbols.Strings: A string is a finite-length sequence of symbols.Languages and Problems: A language is a (possibly infinite) set of strings, all of which choose their symbols from some one alphabet. When the strings of a language are to be interpreted in some way, the question of whether a string is in the language is sometimes called a problem.","keywords":"","version":"Next"},{"title":"Lesson 2","type":0,"sectionRef":"#","url":"/docs/Automata Theory/Lesson 2","content":"","keywords":"","version":"Next"},{"title":"DFA与NFA的等价性​","type":1,"pageTitle":"Lesson 2","url":"/docs/Automata Theory/Lesson 2#dfa与nfa的等价性","content":" ","version":"Next","tagName":"h2"},{"title":"ChatGPT给出的证明​","type":1,"pageTitle":"Lesson 2","url":"/docs/Automata Theory/Lesson 2#chatgpt给出的证明","content":" ","version":"Next","tagName":"h3"},{"title":"老师给出的证明​","type":1,"pageTitle":"Lesson 2","url":"/docs/Automata Theory/Lesson 2#老师给出的证明","content":" ∀NFA N,∃DFA M,that L(N)=L(M)\\forall NFA\\;N,\\exists DFA\\;M,that\\;L(N)=L(M)∀NFAN,∃DFAM,thatL(N)=L(M)  ℵ\\Huge\\alephℵ  ","version":"Next","tagName":"h3"},{"title":"Work​","type":1,"pageTitle":"Lesson 2","url":"/docs/Automata Theory/Lesson 2#work","content":" μ∗(ϵ(R),w)=∪q∈Rσ∗(q,w)\\mu^*(\\epsilon(R),w)=\\cup_{q\\in R}\\sigma^*(q,w)μ∗(ϵ(R),w)=∪q∈R​σ∗(q,w)  R=q0R={q_0}R=q0​  ∪q∈Rϵ(q0)=ϵ(R)\\underset{q \\in R}{\\cup}\\epsilon({q_0})=\\epsilon(R)q∈R∪​ϵ(q0​)=ϵ(R) ","version":"Next","tagName":"h2"},{"title":"Heading 1","type":0,"sectionRef":"#","url":"/docs/Functional Analysis/test1","content":"test1 Heading 1 Quote This is inline math expression: y=x2y=x^2y=x2. This is math expression: ϵ=hv˙\\epsilon=h\\dot vϵ=hv˙","keywords":"","version":"Next"},{"title":"Lesson 1","type":0,"sectionRef":"#","url":"/docs/Computer Architecture/Lesson 1","content":"Lesson 1","keywords":"","version":"Next"},{"title":"Glossary","type":0,"sectionRef":"#","url":"/docs/Linear Algebra/Glossary","content":"","keywords":"","version":"Next"},{"title":"V​","type":1,"pageTitle":"Glossary","url":"/docs/Linear Algebra/Glossary#v","content":" vector space, a vector space is a set with operations of addition and scalar multiplication that satisfy natural algebraic properties. ","version":"Next","tagName":"h2"},{"title":"Lesson 2","type":0,"sectionRef":"#","url":"/docs/Computer Architecture/Lesson 2","content":"Lesson 2 CPU time for a program can be expressed in two ways: TCPU=Nclock cycles×Tclock cycleT_{CPU}=N_{clock\\;cycles}\\times T_{clock\\;cycle}TCPU​=Nclockcycles​×Tclockcycle​TCPU=Nclock cyclesClock rateT_{CPU}=\\dfrac{N_{clock\\;cycles}}{Clock\\;rate}TCPU​=ClockrateNclockcycles​​ TCPUT_{CPU}TCPU​: CPU time Nclock cyclesN_{clock\\;cycles}Nclockcycles​: Clock cycles for a program Tclock cycleT_{clock\\;cycle}Tclockcycle​: Clock cycle time","keywords":"","version":"Next"},{"title":"Notation","type":0,"sectionRef":"#","url":"/docs/Linear Algebra/Notation","content":"","keywords":"","version":"Next"},{"title":"Notation​","type":1,"pageTitle":"Notation","url":"/docs/Linear Algebra/Notation#notation","content":"   The following table shows the notations and their meanings used in the book Linear Algebra Done Right[1] written by Sheldon Axler.  Notation\tExplanationRn\\mathbf R^nRn\t    ","version":"Next","tagName":"h2"},{"title":"Reference​","type":1,"pageTitle":"Notation","url":"/docs/Linear Algebra/Notation#reference","content":" 1. S. Axler, Linear Algebra Done Right. Springer International Publishing, 2024. doi: 10.1007/978-3-031-41026-0. ","version":"Next","tagName":"h2"},{"title":"Heading 1","type":0,"sectionRef":"#","url":"/docs/Functional Analysis/test2","content":"test2 Heading 1 Quote This is inline math expression: y=x2y=x^2y=x2. This is math expression: ϵ=hv˙\\epsilon=h\\dot vϵ=hv˙","keywords":"","version":"Next"},{"title":"Heading 1","type":0,"sectionRef":"#","url":"/docs/Mathematical Analysis/test1","content":"test1 Heading 1 Quote This is inline math expression: y=x2y=x^2y=x2. This is math expression: ϵ=hv˙\\epsilon=h\\dot vϵ=hv˙","keywords":"","version":"Next"},{"title":"Finite Automata","type":0,"sectionRef":"#","url":"/docs/Automata Theory/Finite Automata","content":"","keywords":"","version":"Next"},{"title":"An Informal Picture of Finite Automata​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#an-informal-picture-of-finite-automata","content":" ","version":"Next","tagName":"h2"},{"title":"The Ground Rules​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#the-ground-rules","content":" ","version":"Next","tagName":"h3"},{"title":"Deterministic Finite Automaton, DFA​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#deterministic-finite-automaton-dfa","content":" A deterministic finite automaton consists of:  A finite set of states, often denoted QQQ.A finite set of input symbols, often denoted Σ\\SigmaΣ.A transition function that takes as arguments a state and an input symbol and returns a state, often denoted δ\\deltaδ. In our formal graph representation of automata, δ\\deltaδ was represented by arcs between states and the labels on the arcs. If qqq is a state, and aaa is an input symbol, then δ(q,a)\\delta(q,a)δ(q,a) is that state ppp such that there is an arc labeled aaa from qqq to ppp.A start state, one of the states in QQQ.A set of final or accepting states FFF. The set FFF is a subset of QQQ.  A deterministic finite automaton wiU often be referred to by its acronym: DFA. The most succinct representation of a DFA is a listing of the five components above. In proofs we often talk about a DFA in &quot;five-tuple&quot; notation:  A=(Q,Σ,δ,q0,F)A=(Q,\\Sigma,\\delta,q_0,F)A=(Q,Σ,δ,q0​,F)  where AAA is the name of DFA, QQQ is its set of states, Σ\\SigmaΣ its input symbols, ]delta]delta]delta its transition function, q0q_0q0​ its start state, and FFF its set of accepting states.  ","version":"Next","tagName":"h2"},{"title":"How a DFA Processes Strings​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#how-a-dfa-processes-strings","content":" The first thing we need to understand about a DFA is how the DFA decides whether or not to &quot;accept&quot; a sequence of input symbols. The &quot;language&quot; of the DFA is the set of all strings that the DFA accepts. Suppose a1a2⋯ana_1a_2\\cdots a_na1​a2​⋯an​ is a sequence of input symbols. We start out with the DFA in its start state, q0q_0q0​. We consult the transition function δ\\deltaδ, say δ(q0,a1)=q1\\delta(q_0,a_1)=q_1δ(q0​,a1​)=q1​ to find the state that the DFA AAA enters after processing the first input symbol a1a_1a1​. We process the next input symbol, a2a_2a2​, by evaluating δ(q1,a2)\\delta(q_1,a_2)δ(q1​,a2​); let us suppose this state is q2q_2q2​. We continue in this manner, finding states q3,q4,…,qnq_3,q_4,\\dots,q_nq3​,q4​,…,qn​ such that δ(qi−1,ai)=qi\\delta(q_{i-1},a_i)=q_iδ(qi−1​,ai​)=qi​ for each iii. If qnq_nqn​ is a member of FFF, then the input a1a2⋯ana_1a_2\\cdots a_na1​a2​⋯an​ is accepted, and if not then it is &quot;rejected&quot;.  ","version":"Next","tagName":"h3"},{"title":"Simpler Notations for DFA's​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#simpler-notations-for-dfas","content":" Specifying a DFA as a five-tuple with a detailed description of the ð transition function is both tedious and hard to read. There are two preferred notations for describing automata:  A transition diagram, which is a graph such as the ones we saw before.A transition table, which is a tabular listing of δ\\deltaδ function, which by implication tells us the set of states and the input alphabet.  Transition Diagrams​  A transition diagram for a DFA A=(Q,Σ,δ,q0,F)A=(Q,\\Sigma,\\delta,q_0,F)A=(Q,Σ,δ,q0​,F) is a graph defined as follows:  For each state in QQQ there is a node.For each state qqq in QQQ and each input symbol aaa in Σ\\SigmaΣ, let δ(q,a)=p\\delta(q,a)=pδ(q,a)=p.Then the transition diagram has an arc from node qqq to node ppp, labeled aaa. If there are several input symbols that cause transitions from aaa to ppp, then the transition diagram can have one arc, labeled by the list of these symbols.There is an arrow into the state state q0q_0q0​, labeled Start. This arrow does not originate at any node.Nodes corresponding to accepting states (those in FFF) are marked by a double circle. States noe in FFF have a single circle.  Figure 1 shows the transition diagram for the DFA that we designed before.  Figure 1. The transition diagram for the DFA accepting all strings with a substring &quot;01&quot;.  ","version":"Next","tagName":"h3"},{"title":"Nondeterministic Finite Automata, NfA​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#nondeterministic-finite-automata-nfa","content":" A &quot;nondeterministic&quot; finite automaton (NFA) has the power to be in several states at once. This ability is often expressed as an ability to &quot;guess&quot; something about its input. The NFA's accept exactly the regular languages, just as DfA's do. They are often more succinct and easier to design than DFA's, and we can always convert an NFA to a DFA. The latter may have exponentially more states than the NFA; fortunately, cases of this type are rare.  ","version":"Next","tagName":"h2"},{"title":"An Informal View of Nondeterministic Finite Automata​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#an-informal-view-of-nondeterministic-finite-automata","content":" Figure 2 shows a nondeterministic finite automaton, whose job is to accept all and only the strings of 0's and 1's that end in &quot;01&quot;.  Figure 2. An NFA accepting all strings that end in &quot;01&quot;.  ","version":"Next","tagName":"h3"},{"title":"Definition of Nondeterministic Finite Automata​","type":1,"pageTitle":"Finite Automata","url":"/docs/Automata Theory/Finite Automata#definition-of-nondeterministic-finite-automata","content":" An NFA is represented essentially like a DFA:  A=(Q,E,δ,q−0,F)A=(Q,\\Epsilon,\\delta,q-0,F)A=(Q,E,δ,q−0,F)  where:  QQQ is a finite set of states.E\\EpsilonE is a finite set of input symbols.q0q_0q0​, a member of QQQ, is the start state.FFF, a subset of QQQ, is the set of final (or accepting) states.δ\\deltaδ, the transition function is a function that takes a state in QQQ and an input symbol in E\\EpsilonE as arguments and returns a subset of QQQ. Notice that the only difference between an NFA and a DFA is in the type of value that δ\\deltaδ returns: a set of states in the case of an NFA and a single state in the case of a DFA. ","version":"Next","tagName":"h3"},{"title":"Heading 1","type":0,"sectionRef":"#","url":"/docs/Mathematical Analysis/test2","content":"test2 Heading 1 Quote This is inline math expression: y=x2y=x^2y=x2. This is math expression: ϵ=hv˙\\epsilon=h\\dot vϵ=hv˙","keywords":"","version":"Next"},{"title":"Definition","type":0,"sectionRef":"#","url":"/docs/Linear Algebra/Definition","content":"","keywords":"","version":"Next"},{"title":"Complex Numbers​","type":1,"pageTitle":"Definition","url":"/docs/Linear Algebra/Definition#complex-numbers","content":" We assume the root of −1-1−1 is iii, (i2=−1i^2=-1i2=−1), which obeys the usual rules of arithmetic.  A complex number is an ordered pair (a,b)(a,b)(a,b), where a,b∈Ra, b \\in Ra,b∈R, but we will write this as a+bia+bia+bi. The set of all complex numbers is denoted by C\\mathbf{C}C: C={a+bi:a,b∈R}\\mathbf{C}=\\{a+bi:a,b\\in \\mathbf{R}\\}C={a+bi:a,b∈R} Addition and multiplication on C\\mathbf{C}C are defined by (a+bi)+(c+di)=(a+c)+(b+d)i,(a+bi)+(c+di)=(a+c)+(b+d)i,(a+bi)+(c+di)=(a+c)+(b+d)i,(a+bi)(c+di)=(ac−bd)+(ad+bc)i;(a+bi)(c+di)=(ac-bd)+(ad+bc)i;(a+bi)(c+di)=(ac−bd)+(ad+bc)i; here a,b,c,d∈Ra,b,c,d\\in \\mathbf{R}a,b,c,d∈R.  Notation\tExplanationR\\mathbf RR\tA set of real numbers. ","version":"Next","tagName":"h2"},{"title":"Automata: The Methods and the Madness","type":0,"sectionRef":"#","url":"/docs/Automata Theory/Automata: The Methods and the Madness","content":"","keywords":"","version":"Next"},{"title":"Why Study Automata Theory?​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#why-study-automata-theory","content":" ","version":"Next","tagName":"h2"},{"title":"Introduction to Finite Automata​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#introduction-to-finite-automata","content":" Automata theory is the study of abstract computing devices or &quot;machines&quot;.  Finite automata are a useful model for many important kinds of hardware and software.  Software for designing and checking the behavior of digital circuits.The &quot;lexical analyzer&quot; of a typical compiler, that is, the compiler component that breaks the input text into logical units, such as identifiers, keywords, and punctuation.Software for scanning large bodies of text, such as collections of Web pages, to find occurrences of words, phrases,or other patterns.Software for verifying systems of all types that have a finite number of distinct states, such as communications protocols or protocols for secure exchange of information.  Perhaps the simplest nontrivial finite automaton is an on/off switch (Figure 1).  Figure 1. A simple finite automaton.  Figure 2 shows another finite automaton that could be part of a lexical analyzer. The job of this automaton is to recognize the keyword then. It thus needs five states, each of which represents a different position in the word then that has been reached so far. These positions correspond to the prefixes of the word, ranging from the empty string (i.e., nothing of the word has been seen so far) to the complete word. We could consider the state &quot;then&quot; as accepting state.  Figure 2. A finite automaton modeling recognition of then.  ","version":"Next","tagName":"h3"},{"title":"Structural Representations​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#structural-representations","content":" There are two important notations that are not automaton-like, but play an important role in the study of automata and their applications.  Grammars are useful models when designing software that processes data with a recursive structure. The best-known example is a &quot;parser&quot;, the component of a compiler that deals with the recursively nested features of the typical programming language, such as expressions-arithmetic, conditional, and so on. For instance,a grammatical rule like E⇒E+EE\\Rightarrow E+EE⇒E+E states that an expression can be formed by taking any two expressions and connecting them by a plus sign; this rule is typical of how expressions of real programming languages are formed. Later, we'll introduce context-free grammars, as they are usually called.Regular Expressions also denote the structure of data, especially text strings. The patterns of strings they describe are exactly the same as what can be described by finite automata. The style of these expressions differs significantly from that of grammars, and we shall content ourselves with a simple example here. The UNIX-style regular expression [A-Z][a-z]*[ ][A-Z][A-Z], represents capitalized words followed by a space and two capital letters. This expression represents patterns in text that could be a city and state, e.g., Ithaca NY. It misses multiword city names, such as Palo Alto CA, which could be captured by the more complex expression [A-Z][a-z]*([ ][A-Z] [a-z]*)*[ ][A-Z][A-Z].  ","version":"Next","tagName":"h3"},{"title":"Automata and Complexity​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#automata-and-complexity","content":" Automata are essential for the study of the limits of computation. As we mentioned in the introduction to the chapter, there are two important issues:  What can a computer do at all? This study is called &quot;decidability,&quot; and the problems that can be solved by computer are called &quot;decidable.&quot;What can a computer do efficiently? This study is called &quot;intractability,&quot; and the problems that can be solved by a computer using no more time than some slowly growing function of the size of the input are called &quot;tractable.&quot; Often,we take all polynomial functions to be &quot;slowly growing,&quot; while functions that grow faster than any polynomial are deemed to grow too fast.  ","version":"Next","tagName":"h3"},{"title":"Introduction to Formal Proof​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#introduction-to-formal-proof","content":" Perhaps more than other core subjects of computer science, automata theory lends itself to natural and interesting proofs, both of the deductive kind (a sequence of justified steps) and the inductive kind (recursive proofs of a parameterized statement that use the statement itself with &quot;lower&quot; values of the parameter).  ","version":"Next","tagName":"h2"},{"title":"Deductive Proofs​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#deductive-proofs","content":" A deductive proof consists of a sequence of statements whose truth leads us from some initial statement, called the hypothesis or the given statement(s), to a conclusion statement. Each step in the proof must follow, by some accepted logical principle, from either the given facts, or some of the previous statements in the deductive proof, or a combination of these.  The hypothesis may be true or false, typically depending on values of its parameters. Often, the hypothesis consists of several independent statements connected bya logical AND. In those cases, we talk of each of these statements as a hypothesis, or as a given statement.  The theorem that is proved when we go from a hypothesis HHH to a conclusion CCC is the statement &quot;if HHH then CCC.&quot; We say that CCC is deduced from HHH.  ","version":"Next","tagName":"h3"},{"title":"Reduction to Definitions​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#reduction-to-definitions","content":" In many other theorems, including many from automata theory, the terms used in the statement may have implications that are less obvious.  tip If you are not sure how to start a proof, convert all terms in the hypothesis to their definitions.  Here is an example of a theorem that is simple to prove once we have expressed its statement in elementary terms. It uses the following two definitions:  A set SSS is finite if there exists an integer nnn such that SSS has exactly nnn elements in a set SSS. We write ∥S∥=n\\| S\\|=n∥S∥=n, where ∥S∥\\|S\\|∥S∥ is used to denote the number of elements in a set SSS. If the set SSS is not finite, we say SSS is infinite. Intuitively, an infinite set is a set that contains more than any integer number of elements.If SSS and TTT are both subsets of some set UUU, then TTT is the complement of SSS (with respect to UUU) if S∪T=US\\cup T=US∪T=U and S∩T=∅S\\cap T=\\emptysetS∩T=∅. That is, each element of UUU is in exactly those elements off UUU that are not in SSS.  Theorem Let SSS be a finite subset of some infinite set UUU. Let TTT be the complement of SSS with respect to UUU. Then TTT is infinite.  ","version":"Next","tagName":"h3"},{"title":"Other Theorem Forms​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#other-theorem-forms","content":" Ways of Saying &quot;If-Then&quot;​  Here are some of the other ways in which &quot;if HHH then CCC&quot; might appear.  HHH implies CCC.HHH only if CCC.CCC if HHH.Whenever HHH holds, CCC follows. If HHH holds, then CCC follows.Whenever HHH holds, CCC holds.  In formal logic one often sees the operator →\\rightarrow→ in place of &quot;if-then&quot;. That is, the statement &quot;if HHH then CCC&quot; could appear as H→CH\\rightarrow CH→C in some mathematical literature.  If-And-Only-If Statements​  In formal logic, one may see the operator ⇔\\Leftrightarrow⇔ or ≡\\equiv≡ to denote an &quot;if-and-only-if&quot; statement. That is, A≡BA\\equiv BA≡B and A⇔BA\\Leftrightarrow BA⇔B mean the same as &quot;AAA if and only if BBB&quot;.  tip When proving an if-and-only-if statement, it is important to remember that you must prove both the &quot;if&quot; and &quot;only-if&quot; parts. Sometimes, you will find it helpful to break an if-and-only-if into a succession of several equivalences. That is, to prove &quot;AAA if and only if BBB&quot;, you might first prove &quot;AAA if and only if CCC&quot; and then prove &quot;CCC if and only if BBB&quot;.  Theorem Let xxx be a real number. Then ⌊x⌋=⌈x⌉\\lfloor x\\rfloor=\\lceil x\\rceil⌊x⌋=⌈x⌉ if and only if xxx is an integer. ⌊x⌋\\lfloor x\\rfloor⌊x⌋, the floor of a real number, is the greatest integer equal to or less than xxx. ⌈x⌉\\lceil x\\rceil⌈x⌉, the ceil of a real number, is the least integer equal to or greater than xxx.  ","version":"Next","tagName":"h3"},{"title":"Theorems That Appear Not to Be If-Then Statements​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#theorems-that-appear-not-to-be-if-then-statements","content":" Sometimes,we encounter a theorem that appears not to have a hypothesis. An example is the well-known fact from trigonometry:  Pythagorean Identity Theorem sin⁡2θ+cos⁡2θ=1\\sin^2\\theta+\\cos^2\\theta=1sin2θ+cos2θ=1  ","version":"Next","tagName":"h3"},{"title":"Additional Forms of Proof​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#additional-forms-of-proof","content":" In this section,we take up several additional topics concerning how to construct proofs:  Proofs about sets.Proofs by contradiction.Proofs by counterexample.  ","version":"Next","tagName":"h2"},{"title":"Proving Equivalences About Sets​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#proving-equivalences-about-sets","content":" The Distributive Law of Union Over Intersection Theorem R∪(S∩T)=(R∪S)∩(R∪T)R\\cup(S\\cap T)=(R\\cup S)\\cap(R\\cup T)R∪(S∩T)=(R∪S)∩(R∪T) An element xxx is in R∪(S∩T)R\\cup(S\\cap T)R∪(S∩T) if and only if xxx is in (R∪S)∩(R∪T)(R\\cup S)\\cap(R\\cup T)(R∪S)∩(R∪T). The elements of R∪(S∩T)R\\cup(S\\cap T)R∪(S∩T) are all and only the elements of (R∪S)∩(R∪T)(R\\cup S)\\cap(R\\cup T)(R∪S)∩(R∪T).  ","version":"Next","tagName":"h3"},{"title":"The Contrapositive​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#the-contrapositive","content":" Every if-then statement has an equivalent form that in some circumstances is easier to prove. The contrapositive of the statement &quot;if HHH then CCC&quot; is &quot;if not CCC then not HHH&quot;.  A statement and its contrapositive are either both true or both false,so we can prove either to prove the other.  ","version":"Next","tagName":"h3"},{"title":"Proof by Contradiction​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#proof-by-contradiction","content":" Another way to prove a statement of the form &quot;if HHH then CCC&quot; is to prove the statement: HHH and not CCC implies falsehood.  ","version":"Next","tagName":"h3"},{"title":"Counterexamples​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#counterexamples","content":" In real life,we are not told to prove a theorem. Rather,we are faced with something that seems true - a strategy for implementing a program for example - and we need to decide whether or not the &quot;theorem&quot; is true. To resolve the question, we may alternately try to prove the theorem, and if we cannot, try to prove that its statement is false.  Theorems generallyare statements about an infinite number of cases, perhaps all values of its parameters. Indeed, strict mathematical convention will only dignify a statement with the title &quot;theorem&quot; if it has an infinite number of cases; statements that have no parameters, or that apply to only a finite number of values of its parameter(s)are called observations. It is sufficient to show that an alleged theorem is false in any one case in order to show it is not a theorem. The situation is analogous to programs, since a program is generally considered to have a bug if it fails to operate correctly for even one input on which it was expected to work.  It often is easier to prove that a statement is not a theorem than to prove it is a theorem.  ","version":"Next","tagName":"h3"},{"title":"Inductive Proofs​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#inductive-proofs","content":" There is a special form of proof, called &quot;inductive&quot;, that is essential when dealing with recursively defined objects.  ","version":"Next","tagName":"h2"},{"title":"Inductions on Integers​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#anchor1","content":" Suppose we are given a statement S(n)S(n)S(n), about an integer nnn, to prove. One common approach is to prove 2 things:  The basis, where we show S(i)S(i)S(i) for a particular integer iii. Usually, i=0i=0i=0 or i=1i=1i=1, but there are examples where we want to start at some higher iii, perhaps because the statement SSS is false for a few small integers.The inductive step, where we assume n≥in\\geq in≥i, where iii is the basis integer, and we show that &quot;if S(n)S(n)S(n) then S(n+1)S(n+1)S(n+1)&quot;.  The Induction Principle: If we prove S(i)S(i)S(i) and we prove that for all n≥in\\geq in≥i,S(n)S(n)S(n) implies S(n+1)S(n+1)S(n+1), then we may conclude S(n)S(n)S(n) for all n≥in\\geq in≥i.  ","version":"Next","tagName":"h3"},{"title":"More General Forms of Integer Inductions​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#more-general-forms-of-integer-inductions","content":" Sometimes an inductive proof is made possible only by usinga more general scheme than the one proposed here, where we proved a statement SSS for one basis value and then proved that &quot;if S(n)S(n)S(n) then S(n+1)S(n+1)S(n+1)&quot;. Two important generalizations of this scheme are:  We can use several basis cases. That is, we prove S(i),S(i+1),…,S(j)S(i),S(i+1),\\dots,S(j)S(i),S(i+1),…,S(j) for some j&gt;ij&gt;ij&gt;i. In proving S(n+1)S(n+1)S(n+1), we can use the truth of all the statements S(i),S(i+1),…,S(j)S(i),S(i+1),\\dots,S(j)S(i),S(i+1),…,S(j) rather than just using S(n)S(n)S(n). Moreover, if we have proved basis cases up to S(j)S(j)S(j), then we can assume n≥jn\\geq jn≥j, rather than just n≥in\\geq in≥i.  ","version":"Next","tagName":"h3"},{"title":"Structural Inductions​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#structural-inductions","content":" Like inductions, all recursive definitions have a basis case, where one or more elementary structures are defined, and an inductive step, where more complex structures are defined in terms of previously defined structures.  Inductive construction of a tree Definition Basis: A single node is a tree, and that node is the root of the tree. Induction: If T1,T2,…,TkT_1,T_2,\\dots,T_kT1​,T2​,…,Tk​ are trees, then we can form a new tree as follows: Begin with a new node NNN, which is the root of the tree.Add copies of all the trees T1,T2,…,TkT_1,T_2,\\dots,T_kT1​,T2​,…,Tk​.Add edges from node NNN to the roots of each of the trees T1,T2,…,TkT_1,T_2,\\dots,T_kT1​,T2​,…,Tk​.  Figure 3 shows the inductive construction of a tree with the root NNN from kkk smaller trees.  Figure 3. Inductive construction of a tree.  ","version":"Next","tagName":"h3"},{"title":"Mutual Inductions​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#mutual-inductions","content":" Sometimes, we cannot prove a single statement by induction, but rather need to prove a group of statements S1(n),S2(n),…,Sk(n)S_1(n),S_2(n),\\dots,S_k(n)S1​(n),S2​(n),…,Sk​(n) together by induction on nnn.  Strictly speaking, proving a group of statements is no different from proving the conjunction (logical AND) of all the statements.  However, when there are really several independent statements to prove, it is generally less confusing to keep the statements separate and to prove them all in their own parts of the basis and inductive steps. We call this sort of proof mutual induction.  We can abstract the pattern for all mutual inductions:  Each of the statements must be proved separately in the basis and in the inductive step.If the statements are &quot;if-and-only-if,&quot; then both directions of each statement must be proved, both in the basis and in the induction.  ","version":"Next","tagName":"h3"},{"title":"The Central Concepts of Automata Theory​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#the-central-concepts-of-automata-theory","content":" ","version":"Next","tagName":"h2"},{"title":"Alphabets​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#alphabets","content":" Alphabets Definition An alphabet is a finite, nonempty set of symbols. Conventionally, we use the symbol Σ\\SigmaΣ for an alphabet. Common alphabets include: Σ={0,1}\\Sigma=\\{0,1\\}Σ={0,1}, the binary alphabet.Σ={a,b,…,z}\\Sigma=\\{a,b,\\dots,z\\}Σ={a,b,…,z}, the set of lower-case letters.The set of all ASCII characters, or the set of all printable ASCII characters.  ","version":"Next","tagName":"h3"},{"title":"Strings​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#strings","content":" Strings Definition A string (or sometimes word) is a finite sequence od symbols chosen from some alphabet.  The Empty String​  The empty string is the string with zero occurrences of symbols. This string, denoted ϵ\\epsilonϵ, is a string that may be chosen from any alphabet whatsoever.  Length of a String​  It is often useful to classify strings by their length, that is, the number of positions for symbols in the string. For instance, 01101 has length 5.  The standard notation for the length of a string www is ∣w∣|w|∣w∣. For example, ∣1011∣=4|1011|=4∣1011∣=4.  Power of an Alphabet​  If Σ\\SigmaΣ is an alphabet, we can express the set of all strings of a certain length from that alphabet by using an exponential notation. We define Σk\\Sigma^kΣk to be the set of strings of length kkk, each of whose symbols is in Σ\\SigmaΣ.  Note that Σ0={ϵ}\\Sigma^0=\\{\\epsilon\\}Σ0={ϵ}, regardless of what alphabet Σ\\SigmaΣ is.  The set of all strings over an alphabet Σ\\SigmaΣ is Σ∗\\Sigma^{*}Σ∗, i.e. {0,1}={ϵ,0,1,00,01,10,11,000,… }\\{0,1\\}=\\{\\epsilon,0,1,00,01,10,11,000,\\dots\\}{0,1}={ϵ,0,1,00,01,10,11,000,…}. That is, Σ∗=Σ0∪Σ1∪Σ2∪…\\Sigma^{*}=\\Sigma^0\\cup\\Sigma^1\\cup\\Sigma^2\\cup\\dotsΣ∗=Σ0∪Σ1∪Σ2∪….  The set of nonempty strings from alphabet Σ\\SigmaΣ is denoted Σ+\\Sigma^+Σ+. Thus, two appropriate equivalences are:  Σ+=Σ1∪Σ2Σ3∪…\\Sigma^+=\\Sigma^1\\cup\\Sigma^2\\Sigma^3\\cup\\dotsΣ+=Σ1∪Σ2Σ3∪…;Σ∗=Σ+∪{ϵ}\\Sigma^*=\\Sigma^+\\cup\\{\\epsilon\\}Σ∗=Σ+∪{ϵ}.  tip Σ\\SigmaΣ is an alphabet, Σ1\\Sigma^1Σ1 is a set of strings (length = 1).  Concatenation of Strings​  Let xxx and yyy be strings, then xyxyxy denotes the concatenation of xxx and yyy. That is, the string formed by making a copy of xxx and following it by a copy of yyy. More precisely, if xxx is the string composed of iii symbols x=a1a2⋯aix=a_1a_2\\cdots a_ix=a1​a2​⋯ai​ and yyy is the string composed of jjj symbols y=b1b2⋯bjy=b_1b_2\\cdots b_jy=b1​b2​⋯bj​, then xyxyxy is the string of length i+j: xy=a1a2⋯aib1b2⋯bji+j:\\;xy=a_1a_2\\cdots a_ib_1b_2\\cdots b_ji+j:xy=a1​a2​⋯ai​b1​b2​⋯bj​.  ","version":"Next","tagName":"h3"},{"title":"Languages​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#languages","content":" A set of strings all of which are chosen from some Σ∗\\Sigma^*Σ∗, where Σ\\SigmaΣ is a particular alphabet, is called a language. If Σ\\SigmaΣ is an alphabet, and L⊆Σ∗L\\subseteq \\Sigma^*L⊆Σ∗, then LLL is a language over Σ\\SigmaΣ.  Notice that a language over Σ\\SigmaΣ need not include strings with all the symbols of Σ\\SigmaΣ, so once we have established that LLL is a language over Σ\\SigmaΣ, we also know it is a language over any alphabet that is a superset of Σ\\SigmaΣ.  ∅\\emptyset∅, the empty language, is a language over any alphabet.  {ϵ}\\{\\epsilon\\}{ϵ}, the language consisting of only the empty string, is also a language over any alphabet.  ∅≠{ϵ}\\emptyset \\neq \\{\\epsilon\\}∅={ϵ}, the former has no strings and the latter has one string.  The only important constraint on what can be a language is that all alphabets are finite. Thus languages, although they can have. an infinite number of strings, are restricted to consist of strings drawn from one fixed, finite alphabet.  It is common to describe a language using a &quot;set-former&quot;:  {w∣somthing about w}.\\{w|somthing\\;about\\;w\\}.{w∣somthingaboutw}.  For example:  {w∣w is a binary integer that is prime}.\\{w|w\\;is\\;a\\;binary\\;integer\\;that\\;is\\;prime\\}.{w∣wisabinaryintegerthatisprime}.  It is also common to replace www by some expression with parameters and describe the strings in the language by stating conditions on the parameters. For example:  {0n1n∣n≥1}.\\{0^n1^n|n\\geq 1\\}.{0n1n∣n≥1}.  which is {01,0011,000111,… }\\{01,0011,000111,\\dots\\}{01,0011,000111,…}.  ","version":"Next","tagName":"h3"},{"title":"Problems​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#problems","content":" In automata theory, a problem is the question of deciding whether a given string is a member of some particular language. It turns out, as we shall see, that anything we more colloquially call a &quot;problem&quot; can be expressed as membership in a language. More precisely, if Σ\\SigmaΣ is an alphabet, and LLL is a language over Σ\\SigmaΣ, then the problem LLL is:  Given a string www in Σ∗\\Sigma^*Σ∗, decide whether or not www is in LLL.  ","version":"Next","tagName":"h3"},{"title":"Reference​","type":1,"pageTitle":"Automata: The Methods and the Madness","url":"/docs/Automata Theory/Automata: The Methods and the Madness#reference","content":" 1. J. E. Hopcroft, R. Motwani, and J. D. Ullman, Introduction to automata theory, languages, and computation, 2nd edition, vol. 32, no. 1. New York, NY, USA: ACM Press, 2001, pp. 60-65. ","version":"Next","tagName":"h2"}],"options":{"language":["en","zh"],"highlightResult":true,"id":"default"}}